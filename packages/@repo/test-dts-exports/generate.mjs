import fs from 'node:fs'
import {writeFile} from 'node:fs/promises'
import path from 'node:path'

import rootJson from '@repo/test-dts-exports/package.json' with {type: 'json'}
import {format as prettierFormat, resolveConfig as resolvePrettierConfig} from 'prettier'
import {Project} from 'ts-morph'

const {dependencies} = rootJson

const fixtures = new Map()

for (const packageName of Object.keys(dependencies)) {
  const {default: packageJson} = await import(`${packageName}/package.json`, {with: {type: 'json'}})
  if (!packageJson.exports) {
    continue
  }
  for (const [key, value] of Object.entries(packageJson.exports)) {
    if (typeof value === 'object' && 'default' in value) {
      console.log(path.join(packageName, value.default).replace(/\.(m|c)?js$/, '.d.ts'))
      fixtures.set(
        path.join(packageName, key),
        path.join(packageName, value.default).replace(/\.(m|c)?js$/, '.d.ts'),
      )
    }
  }
}

const fixturesDir = path.join(process.cwd(), 'test', 'fixtures')
if (!fs.existsSync(fixturesDir)) {
  fs.mkdirSync(fixturesDir, {recursive: true})
}

const prettierConfig = await resolvePrettierConfig(path.join(fixturesDir, 'mock.test-d.ts'))

for (const [key, value] of fixtures) {
  const fixtureName = key.replaceAll('/', '.')
  const fixturePath = path.join(fixturesDir, `${fixtureName}.test-d.ts`)

  const project = new Project()
  const sourceFile = project.addSourceFileAtPath(`node_modules/${value}`)
  const exps = sourceFile.getExportedDeclarations()
  if (exps.size === 0) {
    console.warn(`No exports found for ${key}`)
    continue
  }

  // Generate the test content
  let testContent = `// Auto-generated by running \`pnpm generate:dts-exports\`
   import type { ${Array.from(new Set(exps.keys()))
     .map((name) => (name === 'default' ? 'default as _default' : name))
     .join(', ')} } from "${key}";
   import { describe, expectTypeOf, test } from "vitest";

   describe(${JSON.stringify(key)}, () => {
   `

  for (const [name, decls] of exps) {
    if (decls.length === 0) {
      console.warn(`No declarations found for ${name} in ${key}`)
      continue
    }
    const exportName = name === 'default' ? '_default' : name
    for (const decl of decls) {
      const genericParamsCount = decl.getTypeParameters?.().length ?? 0
      const genericParams =
        genericParamsCount > 0 ? `<${Array(genericParamsCount).fill('any').join(', ')}>` : ''
      switch (decl.getKindName()) {
        case 'InterfaceDeclaration':
          testContent += `test(${JSON.stringify(name)}, () => { expectTypeOf<${exportName}${genericParams}>().toBeObject(); });\n`
          break
        case 'ClassDeclaration':
        case 'TypeAliasDeclaration':
          testContent += `test(${JSON.stringify(name)}, () => { expectTypeOf<${exportName}${genericParams}>().not.toBeNever(); });\n`
          break
        case 'VariableDeclaration':
          testContent += `test(${JSON.stringify(name)}, () => { expectTypeOf<typeof ${exportName}>().not.toBeNever(); });\n`
          break
        case 'FunctionDeclaration':
          testContent += `test(${JSON.stringify(name)}, () => { expectTypeOf<typeof ${exportName}>().toBeFunction(); });\n`
          break
        case 'ModuleDeclaration':
          testContent += `test(${JSON.stringify(name)}, () => { expectTypeOf<typeof ${exportName}>().not.toBeNever(); });\n`
          break
        default:
          testContent += `test.todo(${JSON.stringify(name)}, () => { /* ${decl.getKindName()} */ expectTypeOf<${exportName}${genericParams}>().not.toBeNever(); });\n`
          break
      }
    }
  }

  testContent += `})`

  await writeFile(
    fixturePath,
    await prettierFormat(testContent, {
      ...prettierConfig,
      parser: 'typescript',
    }),
  )
}
